# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

wipe_pedigrees <- function(pedigrees) {
    invisible(.Call('_malan_wipe_pedigrees', PACKAGE = 'malan', pedigrees))
}

#' Build pedigrees from (individuals in) a population.
#' 
#' In a newly simulated population, each individual only knows its father and children. 
#' Using this information, this function builds pedigrees.
#' 
#' @param population Population generated by \code{\link{sample_geneology}}.
#' @param progress Show progress.
#' 
#' @return An object with class \code{malan_pedigreelist} (an internal list of external pointers to pedigrees).
#' 
#' @export
build_pedigrees <- function(population, progress = TRUE) {
    .Call('_malan_build_pedigrees', PACKAGE = 'malan', population, progress)
}

#' Simulate a geneology.
#' 
#' This function simulates a geneology where the last generation has \code{population_size} individuals. 
#' 
#' By the backwards simulating process of the Wright-Fisher model, 
#' individuals with no descendants in the end population are not simulated. 
#' If for some reason additional full generations should be simulated, 
#' the number can be specified via the \code{extra_generations_full} parameter.
#' This can for example be useful if one wants to simulate the 
#' final 3 generations although some of these may not get (male) children.
#' 
#' Let \eqn{\alpha} be the parameter of a symmetric Dirichlet distribution 
#' specifying each man's probability to be the father of an arbitrary 
#' male in the next generation. When \eqn{\alpha = 5}, a man's relative probability 
#' to be the father has 95\% probability to lie between 0.32 and 2.05, compared with a 
#' constant 1 under the standard Wright-Fisher model and the standard deviation in 
#' the number of male offspring per man is 1.10 (standard Wright-Fisher = 1).
#' 
#' This symmetric Dirichlet distribution is implemented by drawing 
#' father (unscaled) probabilities from a Gamma distribution with 
#' parameters \code{gamma_parameter_shape} and \code{gamma_parameter_scale} 
#' that are then normalised to sum to 1. 
#' To obtain a symmetric Dirichlet distribution with parameter \eqn{\alpha}, 
#' the following must be used:
#' \eqn{\code{gamma_parameter_shape} = \alpha}
#' and 
#' \eqn{\code{gamma_parameter_scale} = 1/\alpha}.
#' 
#' @param population_size The size of the population.
#' @param generations The number of generations to simulate: 
#'        \itemize{
#'           \item -1 for simulate to 1 founder
#'           \item else simulate this number of generations.
#'        }
#' @param extra_generations_full Additional full generations to be simulated.
#' @param gamma_parameter_shape Parameter related to symmetric Dirichlet distribution for each man's probability to be father. Refer to details.
#' @param gamma_parameter_scale Parameter realted to symmetric Dirichlet distribution for each man's probability to be father. Refer to details.
#' @param enable_gamma_variance_extension Enable symmetric Dirichlet (and disable standard Wright-Fisher).
#' @param progress Show progress.
#' @param individuals_generations_return How many generations back to return (pointers to) individuals for.
#' @param verbose_result Verbose result.
#' 
#' @return A list with the following entries:
#' \itemize{
#'   \item \code{population}. An external pointer to the population.
#'   \item \code{generations}. Generations actually simulated, mostly useful when parameter \code{generations = -1}.
#'   \item \code{founders}. Number of founders after the simulated \code{generations}.
#'   \item \code{growth_type}. Growth type model.
#'   \item \code{sdo_type}. Standard deviation in a man's number of male offspring. StandardWF or GammaVariation depending on \code{enable_gamma_variance_extension}.
#'   \item \code{end_generation_individuals}. Pointers to individuals in end generation.
#'   \item \code{individuals_generations}. Pointers to individuals in end generation in addition to the previous \code{individuals_generations_return}.
#' }
#' If \code{verbose_result} is true, then these additional components are also returned:
#' \itemize{
#'   \item \code{individual_pids}. A matrix with pid (person id) for each individual.
#'   \item \code{father_pids}. A matrix with pid (person id) for each individual's father.
#'   \item \code{father_indices}. A matrix with indices for fathers.
#' }
#' 
#' @import Rcpp
#' @import RcppProgress
#' @import RcppArmadillo
#' @export
sample_geneology <- function(population_size, generations, extra_generations_full = 0L, gamma_parameter_shape = 7, gamma_parameter_scale = 7, enable_gamma_variance_extension = FALSE, progress = TRUE, individuals_generations_return = 2L, verbose_result = FALSE) {
    .Call('_malan_sample_geneology', PACKAGE = 'malan', population_size, generations, extra_generations_full, gamma_parameter_shape, gamma_parameter_scale, enable_gamma_variance_extension, progress, individuals_generations_return, verbose_result)
}

#' Simulate a geneology with varying population size.
#' 
#' This function simulates a geneology with varying population size specified
#' by a vector of population sizes, one for each generation. 
#' 
#' By the backwards simulating process of the Wright-Fisher model, 
#' individuals with no descendants in the end population are not simulated 
#' If for some reason additional full generations should be simulated, 
#' the number can be specified via the \code{extra_generations_full} parameter.
#' This can for example be useful if one wants to simulate the 
#' final 3 generations although some of these may not get (male) children.
#' 
#' Let \eqn{\alpha} be the parameter of a symmetric Dirichlet distribution 
#' specifying each man's probability to be the father of an arbitrary 
#' male in the next generation. When \eqn{\alpha = 5}, a man's relative probability 
#' to be the father has 95\% probability to lie between 0.32 and 2.05, compared with a 
#' constant 1 under the standard Wright-Fisher model and the standard deviation in 
#' the number of male offspring per man is 1.10 (standard Wright-Fisher = 1).
#' 
#' This symmetric Dirichlet distribution is implemented by drawing 
#' father (unscaled) probabilities from a Gamma distribution with 
#' parameters \code{gamma_parameter_shape} and \code{gamma_parameter_scale} 
#' that are then normalised to sum to 1. 
#' To obtain a symmetric Dirichlet distribution with parameter \eqn{\alpha}, 
#' the following must be used:
#' \eqn{\code{gamma_parameter_shape} = \alpha}
#' and 
#' \eqn{\code{gamma_parameter_scale} = 1/\alpha}.
#' 
#' @param population_sizes The size of the population at each generation, g. 
#'        population_sizes[g] is the population size at generation g.
#'        The length of population_sizes is the number of generations being simulated.
#' @param extra_generations_full Additional full generations to be simulated.
#' @param gamma_parameter_shape Parameter related to symmetric Dirichlet distribution for each man's probability to be father. Refer to details.
#' @param gamma_parameter_scale Parameter realted to symmetric Dirichlet distribution for each man's probability to be father. Refer to details.
#' @param enable_gamma_variance_extension Enable symmetric Dirichlet (and disable standard Wright-Fisher).
#' @param progress Show progress.
#' @param individuals_generations_return How many generations back to return (pointers to) individuals for.
#' 
#' @return A malan_simulation / list with the following entries:
#' \itemize{
#'   \item \code{population}. An external pointer to the population.
#'   \item \code{generations}. Generations actually simulated, mostly useful when parameter \code{generations = -1}.
#'   \item \code{founders}. Number of founders after the simulated \code{generations}.
#'   \item \code{growth_type}. Growth type model.
#'   \item \code{sdo_type}. Standard deviation in a man's number of male offspring. StandardWF or GammaVariation depending on \code{enable_gamma_variance_extension}.
#'   \item \code{end_generation_individuals}. Pointers to individuals in end generation.
#'   \item \code{individuals_generations}. Pointers to individuals in end generation in addition to the previous \code{individuals_generations_return}.
#' }
#' 
#' @import Rcpp
#' @import RcppProgress
#' @import RcppArmadillo
#' @export
sample_geneology_varying_size <- function(population_sizes, extra_generations_full = 0L, gamma_parameter_shape = 7, gamma_parameter_scale = 7, enable_gamma_variance_extension = FALSE, progress = TRUE, individuals_generations_return = 2L) {
    .Call('_malan_sample_geneology_varying_size', PACKAGE = 'malan', population_sizes, extra_generations_full, gamma_parameter_shape, gamma_parameter_scale, enable_gamma_variance_extension, progress, individuals_generations_return)
}

#' Simulate a geneology with varying population size.
#' 
#' This function simulates a geneology with varying population size specified
#' by a vector of population sizes, one for each generation. 
#' 
#' By the backwards simulating process of the Wright-Fisher model, 
#' individuals with no descendants in the end population are not simulated 
#' If for some reason additional full generations should be simulated, 
#' the number can be specified via the \code{extra_generations_full} parameter.
#' This can for example be useful if one wants to simulate the 
#' final 3 generations although some of these may not get (male) children.
#' 
#' Let \eqn{\alpha} be the parameter of a symmetric Dirichlet distribution 
#' specifying each man's probability to be the father of an arbitrary 
#' male in the next generation. When \eqn{\alpha = 5}, a man's relative probability 
#' to be the father has 95\% probability to lie between 0.32 and 2.05, compared with a 
#' constant 1 under the standard Wright-Fisher model and the standard deviation in 
#' the number of male offspring per man is 1.10 (standard Wright-Fisher = 1).
#' 
#' This symmetric Dirichlet distribution is implemented by drawing 
#' father (unscaled) probabilities from a Gamma distribution with 
#' parameters \code{gamma_parameter_shape} and \code{gamma_parameter_scale} 
#' that are then normalised to sum to 1. 
#' To obtain a symmetric Dirichlet distribution with parameter \eqn{\alpha}, 
#' the following must be used:
#' \eqn{\code{gamma_parameter_shape} = \alpha}
#' and 
#' \eqn{\code{gamma_parameter_scale} = 1/\alpha}.
#' 
#' @param population_sizes The size of the population at each generation, g. 
#'        population_sizes[g] is the population size at generation g.
#'        The length of population_sizes is the number of generations being simulated.
#' @param extra_generations_full Additional full generations to be simulated.
#' @param gamma_parameter_shape Parameter related to symmetric Dirichlet distribution for each man's probability to be father. Refer to details.
#' @param gamma_parameter_scale Parameter realted to symmetric Dirichlet distribution for each man's probability to be father. Refer to details.
#' @param enable_gamma_variance_extension Enable symmetric Dirichlet (and disable standard Wright-Fisher).
#' @param progress Show progress.
#' @param individuals_generations_return How many generations back to return (pointers to) individuals for.
#' 
#' @return A malan_simulation / list with the following entries:
#' \itemize{
#'   \item \code{population}. An external pointer to the population.
#'   \item \code{generations}. Generations actually simulated, mostly useful when parameter \code{generations = -1}.
#'   \item \code{founders}. Number of founders after the simulated \code{generations}.
#'   \item \code{growth_type}. Growth type model.
#'   \item \code{sdo_type}. Standard deviation in a man's number of male offspring. StandardWF or GammaVariation depending on \code{enable_gamma_variance_extension}.
#'   \item \code{end_generation_individuals}. Pointers to individuals in end generation.
#'   \item \code{individuals_generations}. Pointers to individuals in end generation in addition to the previous \code{individuals_generations_return}.
#' }
#' 
#' @import Rcpp
#' @import RcppProgress
#' @import RcppArmadillo
#' @export
sample_geneology_varying_size_parallel <- function(population_sizes, extra_generations_full = 0L, gamma_parameter_shape = 7, gamma_parameter_scale = 7, enable_gamma_variance_extension = FALSE, progress = TRUE, individuals_generations_return = 2L, threads = 1L) {
    .Call('_malan_sample_geneology_varying_size_parallel', PACKAGE = 'malan', population_sizes, extra_generations_full, gamma_parameter_shape, gamma_parameter_scale, enable_gamma_variance_extension, progress, individuals_generations_return, threads)
}

#' @export
indices_in_mixture <- function(haplotypes, H1, H2) {
    .Call('_malan_indices_in_mixture', PACKAGE = 'malan', haplotypes, H1, H2)
}

#' @export
pedigree_get_haplotypes_pids <- function(population, pids) {
    .Call('_malan_pedigree_get_haplotypes_pids', PACKAGE = 'malan', population, pids)
}

#' @export
individuals_get_haplotypes <- function(individuals) {
    .Call('_malan_individuals_get_haplotypes', PACKAGE = 'malan', individuals)
}

#' @export
pedigree_populate_haplotypes <- function(ped, loci, mutation_rates) {
    invisible(.Call('_malan_pedigree_populate_haplotypes', PACKAGE = 'malan', ped, loci, mutation_rates))
}

#' @export
pedigrees_all_populate_haplotypes <- function(pedigrees, loci, mutation_rates, progress = TRUE) {
    invisible(.Call('_malan_pedigrees_all_populate_haplotypes', PACKAGE = 'malan', pedigrees, loci, mutation_rates, progress))
}

#' @export
get_haplotype <- function(individual) {
    .Call('_malan_get_haplotype', PACKAGE = 'malan', individual)
}

#' @export
count_haplotype_occurrences_individuals <- function(individuals, haplotype) {
    .Call('_malan_count_haplotype_occurrences_individuals', PACKAGE = 'malan', individuals, haplotype)
}

#' @export
meiosis_dist_haplotype_matches_individuals <- function(suspect, individuals) {
    .Call('_malan_meiosis_dist_haplotype_matches_individuals', PACKAGE = 'malan', suspect, individuals)
}

#' @export
pedigree_haplotype_matches_in_pedigree_meiosis_L1_dists <- function(suspect, generation_upper_bound_in_result = -1L) {
    .Call('_malan_pedigree_haplotype_matches_in_pedigree_meiosis_L1_dists', PACKAGE = 'malan', suspect, generation_upper_bound_in_result)
}

#' @export
meiotic_dist <- function(ind1, ind2) {
    .Call('_malan_meiotic_dist', PACKAGE = 'malan', ind1, ind2)
}

#' @export
count_haplotype_occurrences_pedigree <- function(pedigree, haplotype, generation_upper_bound_in_result = -1L) {
    .Call('_malan_count_haplotype_occurrences_pedigree', PACKAGE = 'malan', pedigree, haplotype, generation_upper_bound_in_result)
}

#' @export
get_individual <- function(population, pid) {
    .Call('_malan_get_individual', PACKAGE = 'malan', population, pid)
}

#' @export
get_pid <- function(individual) {
    .Call('_malan_get_pid', PACKAGE = 'malan', individual)
}

#' @export
print_individual <- function(individual) {
    invisible(.Call('_malan_print_individual', PACKAGE = 'malan', individual))
}

#' Get individual's generations
#' 
#' @export
get_generation <- function(individual) {
    .Call('_malan_get_generation', PACKAGE = 'malan', individual)
}

#' Get pedigree from individual
#' 
#' @export
get_pedigree_from_individual <- function(individual) {
    .Call('_malan_get_pedigree_from_individual', PACKAGE = 'malan', individual)
}

#' Get pedigree id from pid
#' 
#' @export
get_pedigree_id_from_pid <- function(population, pids) {
    .Call('_malan_get_pedigree_id_from_pid', PACKAGE = 'malan', population, pids)
}

#' @export
count_brothers <- function(individual) {
    .Call('_malan_count_brothers', PACKAGE = 'malan', individual)
}

#' @export
brothers_matching <- function(individual) {
    .Call('_malan_brothers_matching', PACKAGE = 'malan', individual)
}

#' @export
father_matches <- function(individual) {
    .Call('_malan_father_matches', PACKAGE = 'malan', individual)
}

#' @export
grandfather_matches <- function(individual) {
    .Call('_malan_grandfather_matches', PACKAGE = 'malan', individual)
}

#' @export
count_uncles <- function(individual) {
    .Call('_malan_count_uncles', PACKAGE = 'malan', individual)
}

malan_test <- function() {
    invisible(.Call('_malan_malan_test', PACKAGE = 'malan'))
}

pop_size <- function(population) {
    .Call('_malan_pop_size', PACKAGE = 'malan', population)
}

#' @export
meioses_generation_distribution <- function(individual, generation_upper_bound_in_result = -1L) {
    .Call('_malan_meioses_generation_distribution', PACKAGE = 'malan', individual, generation_upper_bound_in_result)
}

#' @export
population_size_generation <- function(population, generation_upper_bound_in_result = -1L) {
    .Call('_malan_population_size_generation', PACKAGE = 'malan', population, generation_upper_bound_in_result)
}

#' @export
pedigree_size_generation <- function(pedigree, generation_upper_bound_in_result = -1L) {
    .Call('_malan_pedigree_size_generation', PACKAGE = 'malan', pedigree, generation_upper_bound_in_result)
}

#' Get pedigree id
#' 
#' @export
get_pedigree_id <- function(ped) {
    .Call('_malan_get_pedigree_id', PACKAGE = 'malan', ped)
}

#' Get number of pedigrees
#' 
#' @export
pedigrees_count <- function(pedigrees) {
    .Call('_malan_pedigrees_count', PACKAGE = 'malan', pedigrees)
}

#' Get pedigree size
#' 
#' @export
pedigree_size <- function(ped) {
    .Call('_malan_pedigree_size', PACKAGE = 'malan', ped)
}

#' Get distribution of pedigree sizes
#' 
#' @export
pedigrees_table <- function(pedigrees) {
    .Call('_malan_pedigrees_table', PACKAGE = 'malan', pedigrees)
}

get_pedigree <- function(pedigrees, index) {
    .Call('_malan_get_pedigree', PACKAGE = 'malan', pedigrees, index)
}

print_pedigree <- function(ped) {
    invisible(.Call('_malan_print_pedigree', PACKAGE = 'malan', ped))
}

#' get pids in pedigree
#' 
#' @export
get_pids_in_pedigree <- function(ped) {
    .Call('_malan_get_pids_in_pedigree', PACKAGE = 'malan', ped)
}

#' get pids in pedigree
#' 
#' @export
get_haplotypes_in_pedigree <- function(ped) {
    .Call('_malan_get_haplotypes_in_pedigree', PACKAGE = 'malan', ped)
}

get_pedigree_edgelist <- function(ped) {
    .Call('_malan_get_pedigree_edgelist', PACKAGE = 'malan', ped)
}

#' Get pedigree information as graph (mainly intended for plotting)
#' 
#' @export
get_pedigree_as_graph <- function(ped) {
    .Call('_malan_get_pedigree_as_graph', PACKAGE = 'malan', ped)
}

